<style>
    .result-table {
        border-collapse: collapse;
        width: 100%;
        max-width: 1000px;
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }

    .result-table th {
        background-color: #D6E4F2;
        color: #000;
        font-weight: bold;
        padding: 10px;
        border: 1px solid #A0A0A0;
        text-align: center;
    }

    .result-table td {
        background-color: white;
        color: #000;
        padding: 12px 15px;
        border: 1px solid #A0A0A0;
        color: #333;
        font-size: 1.3em;
        font-weight: bold;
    }

    /* 첫 번째 열(입력)과 두 번째 열(출력)의 너비를 동일하게 설정 */
    .result-table th,
    .result-table td {
        width: 33.33%;
    }
</style>

<div class="page-content tex2jax_process">
    <h1>문제 06 실패율★★</h1>
    <p>정답률 _ 60% | 저자 권장 시간 _ 60분 | 권장 시간 복잡도 _ O(M+NlogN) 출제 _ 2019 KAKAO BLIND RECRUITMENT</p>
    <p><a href="https://school.programmers.co.kr/learn/courses/30/lessons/42889" data-google-vignette="false">문제 URL</a></p>
    <hr>
    <p>슈퍼 게임 개발자 오렐리는 큰 고민에 빠졌습니다. 그녀가 만든 프렌즈 오천성이 대성공을 거뒀지만 최근 신규 사용자 수가 급감했기 때문입니다. 원인은 신규 사용자와 기존 사용자 사이에 스테이지 차이가 너무 큰 것이 문제였습니다. 이 문제를 어떻게 할까 고민한 그녀는 동적으로 게임 시간을 늘려서 난이도를 조절하기로 했습니다. 역시 슈퍼 개발자라 대부분의 로직은 쉽게 구현했지만 실패율을 구하는 부분에서 위기에 빠지고 말았습니다. 오렐리를 위해 실패율을 구하는 코드를 완성하세요.</p>
    <ul><li>실패율 정의 : 스테이지에 도달했으나 아직 클리어하지 못한 플레이어의 수 / 스테이지에 도달한 플레이어의 수</li></ul>
    <p>전체 스테이지 개수가 N, 게임을 이용하는 사용자가 현재 멈춰 있는 스테이지의 번호가 담긴 배열 stages가 주어질 때 실패율이 높은 스테이지부터 내림차순으로 스테이지의 번호가 담겨 있는 배열을 반환하도록 solution( ) 함수를 완성하세요.</p>
    <h3 id="_1">제약조건</h3>
    <ul>
        <li>스테이지 개수 N은 1 이상 500 이하의 자연수입니다.</li>
        <li>stages의 길이는 1 이상 200,000 이하입니다.</li>
        <li>stages에는 1 이상 N + 1 이하의 자연수가 있습니다.</li>
        <li>각 자연수는 사용자가 현재 도전 중인 스테이지 번호를 나타냅니다.</li>
        <li>단, N + 1은 마지막 스테이지, 즉, N까지 클리어한 사용자를 나타냅니다.</li>
        <li>만약 실패율이 같은 스테이지가 있다면 작은 번호의 스테이지가 먼저 오면 됩니다.</li>
        <li>스테이지에 도달한 유저가 없는 경우 해당 스테이지의 실패율은 0으로 정의합니다.</li>
    </ul>
    <h3 id="_2">입출력의 예</h3>
    <table class="result-table">
        <thead>
            <tr>
                <th>N</th>
                <th>stages</th>
                <th>result</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>5</td>
                <td>[2,1,2,6,2,4,3,3]</td>
                <td>[3,4,2,1,5]</td>
            </tr>
            <tr>
                <td>4</td>
                <td>[4,4,4,4,4]</td>
                <td>[4,1,2,3]</td>
            </tr>
        </tbody>
    </table>
    <p>1번째 입출력 예를 보면 1번 스테이지에는 총 8명의 사용자가 도전했으며 이 중 1명의 사용자가 아직 클리어하지 못했습니다. 따라서 1번 스테이지의 실패율은 다음과 같습니다.</p>
    <ul><li>1번 스테이지 실패율 : 1/8</li></ul>
    <p>2번 스테이지에는 총 7명의 사용자가 도전했으며, 이 중 3명의 사용자가 아직 클리어하지 못했습니다. 따라서 2번 스테이지의 실패율은 다음과 같습니다.</p>
    <ul><li>2번 스테이지 실패율 : 3/7</li></ul>
    <p>마찬가지로 나머지 스테이지의 실패율은 다음과 같습니다.</p>
    <ul><li>3번 스테이지 실패율 : 2/4</li></ul>
    <ul><li>4번 스테이지 실패율 : 1/2</li></ul>
    <ul><li>5번 스테이지 실패율 : 0/1</li></ul>
    <p>각 스테이지의 번호를 실패율의 내림차순으로 정렬하면 다음과 같습니다.</p>
    <ul><li>[3, 4, 2, 1, 5]</li></ul>
    <p>두 번째 입출력 예를 보면 모든 사용자가 마지막 스테이지에 있으므로 4번 스테이지의 실패율은 1이며 나머지 스테이지의 실패율은 0입니다.</p>
    <ul><li>[4, 1, 2, 3]</li></ul>
    <h3 id="_3">문제 분석하고 풀기</h3>
    <p>구현 난이도 자체가 높지는 않지만 문제를 풀 때 어떤 식으로 접근해야 하는지 연습하기 좋은 문제입니다. 문제에서 새 용어를 정의하는 부분이 나오면 반드시 이해하고 넘어가야 합니다. 바로 그 부분이 문제의 핵심이 되는 경우가 많기 때문입니다. 이 문제에서는 실패율이라는 용어가 나옵니다. 실패율이란 해당 스테이지에 도달한 적이 있는 사용자 중 아직 클리어하지 못한 사용자의 비율을 말합니다. 실패율을 그림으로 생각해보면 다음과 같습니다.</p>
    <img alt="" src="https://static.wikidocs.net/images/page/223088/05-5-06-2.png">
    <p>그림은 스테이지가 4까지 있는 경우, 즉, N이 4입니다. 그림에 스테이지 4 이후 1칸을 더 그린 이유는 스테이지 4까지 클리어한 사람을 표시하기 위함입니다. 그리고 스테이지 3의 실패율은 3 / (3 + 4 + 1)이므로 3/8입니다. 이렇게 각 스테이지의 실패율을 구하고 실패율을 기준으로 내림차순으로 사용자 번호를 정렬해서 반환하면 됩니다. stages가 20만까지 입력될 수 있으므로 시간 초과를 방지하려면 정렬 알고리즘의 시간 복잡도는 O(NlogN)이어야 합니다. 만약 정렬 알고리즘의 시간 복잡도가 O(N2)이라면 시간 초과가 발생할 수 있습니다. 참고로 정렬 문제는 정렬 구현을 시간들여 고민하는 대신 파이썬 제공 함수를 바로 사용해보는 것도 좋은 전략입니다.</p>
<pre><code>
def solution(N, stages):
  # ➊ 스테이지별 도전자 수를 구함
  challenger = [0] * (N + 2)
  for stage in stages:
    challenger[stage] += 1

  #_ ➋ 스테이지별 실패한 사용자 수 계산
  fails = { } 
  total = len(stages) 

  #_ ➌ 각 스테이지를 순회하며, 실패율 계산
  for i in range(1, N + 1):
    if challenger[i] == 0 : # ➍ 도전한 사람이 없는 경우, 실패율은 0
      fails[i] = 0
    else:
      fails[i] = challenger[i] / total # ➎ 실패율 구함
      total -= challenger[i] # ➏ 다음 스테이지 실패율을 구하기 위해 
  #_ 현재 스테이지의 인원을 뺌

  #_ ➐ 실패율이 높은 스테이지부터 내림차순으로 정렬
  result = sorted(fails, key=lambda x : fails[x], reverse=True)

  return result 
</code></pre>
    <p>➊ challenger는 각 스테이지에 도전하는 사용자 수를 저장하는 데 사용하는 배열입니다. 리스트의 크기를 N + 2로 정한 이유도 나름의 문제를 풀기 위한 전략입니다. 왤까요? N번째 스테이지를 클리어한 사용자는 stage가 N + 1입니다. 그러면 challenger 배열에서 N + 1 위치에 데이터를 저장해야 하는데 배열의 인덱스는 0부터 시작하므로 N + 1 인덱스에 데이터를 저장하려면 N + 2 크기의 배열이 필요하기 때문입니다. 물론 이렇게 하면 0번째 인덱스는 사용하지 않아서 낭비라고 생각할 수 있습니다만, 이렇게 하면 실보다 득이 큽니다. 반복문을 보면 각 stages 데이터의 값을 challenger의 인덱스로 사용할 수 있게 됩니다. 이렇게 하면 값 자체를 인덱스로 활용할 수 있어 매우 편리합니다. 메모리 공간 1칸만 비우고 편리함을 취했다고 할 수 있겠네요.</p>
    <p>이와 유사한 정렬 알고리즘은 계수 정렬입니다. 계수 정렬은 이 책의 ‘13장 정렬’에서 설명합니다.</p>
    <p>➋ fails는 실패율을 저장하는 용도이고, total의 값은 총 사용자의 수입니다. 해당 변수들이 어떻게 사용되는지는 아래에 자세히 설명하겠습니다.</p>
    <p>➌은 이 문제의 핵심입니다. 즉, 실패율을 구하는 로직입니다. 위에서 구한 challengers값을 활용해서 실패율을 구합니다.</p>
    <p>➍ 해당 스테이지에 있는 사용자가 0이라면 문제 정의에 의해 실패율은 0이되므로 계산은 간단합니다.</p>
    <p>➎ 해당 스테이지에 사용자가 있다면 실패율 공식을 적용해서 실패율을 구합니다. fails는 리스트가 아니고 딕셔너리라는 것을 기억해야 합니다. 다시 말해 fails[i] = challenger[i] / total에서 키는 i, 값은 challengers[i]이며 이 값들이 쌍을 이뤄 fails 딕셔너리 변수에 저장된다고 보면 됩니다. total의 값은 현재 스테이지에 도달한 사용자 값입니다.</p>
    <p>➏ N번째 스테이지에 도달한 사용자의 수를 구하려면 N-1번째 스테이지에 있는 사용자의 수를 빼면 됩니다. 예를 들어 3번째 스테이지에 도달한 사용자 수를 구하려면 {1, 2}번째 스테이지에 있는 사용자 수를 제외하면 됩니다. 따라서 총 사용자 수에서 각 스테이지의 인원 수를 빼면 이 값이 다음 스테이지에 도달한 사용자 수가 됩니다. 이러한 이유로 total 값은 초기에는 전체 사용자 수에서 시작해서 각 stage의 실패율을 구할 때마다 현재 stage의 인원을 빼며 코드가 실행됩니다. 설명이 꽤 복잡하지만 다음 그림과 설명을 같이 보면 금방 이해할 수 있습니다.</p>
    <img alt="" src="https://static.wikidocs.net/images/page/223088/05-5-06-3.png">
    <p>➐ fails는 딕셔너리입니다. 키는 각 사용자를 가리키는 숫자, 값은 실패율을 의미합니다. 값을 기준으로 키를 정렬해서 반환합니다.</p>
    <h3 id="_4">시간 복잡도 분석하기</h3>
    <p>N은 스테이지의 개수이고, M은 stages의 길이입니다. challenger 배열을 초기화하고, 각 스테이지 도전자 수를 계산할 때 시간 복잡도는 O(N + M)입니다. 이후 스테이지 별로 실패율을 계산하는 데 필요한 시간 복잡도는 O(N)이고, 실패율을 기준으로 스테이지를 정렬할 때의 시간 복잡도는 O(NlogN)입니다. 이 연산들을 모두 고려하면 시간 복잡도는 O(2*N + M + NlogN)이므로 최종 시간 복잡도는 O(M + NlogN)입니다.</p>
</div>